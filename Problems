""":
LONGEST SUBSTRING WITHOUT REPEATING CHARACTER
- We use the sliding window technique with two pointers: left (l) and right (r).
- The right pointer moves forward one character at a time to expand the window.
- A set is used to keep track of characters currently in the window.
- If the character at the right pointer already exists in the set, it means we have a duplicate.
- To resolve this, we shrink the window from the left by removing characters from the set and moving the left pointer forward until the duplicate is removed.
- After adding the current character to the set, we update the maximum window size.
- This process continues until the right pointer has traversed the entire string.
"""


class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        max_len = 0
        l = 0
        seen = set()
        for r in range(len(s)):
            while s[r] in seen:
                seen.remove(s[l])
                l += 1
            seen.add(s[r])
            max_len = max(max_len, r - l + 1)
        return max_len


"""
FIBONACCI
The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).


"""


# Tabulation
class Solution:
    def fib(self, n: int) -> int:

        if n <= 1:
            return n
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 1

        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]

        return dp[i]


# Using Memoization
def fib(n, dp=None):
    if dp is None:
        dp = [-1] * (n + 1)
    if n <= 1:
        return n
    if dp[n] != -1:
        return dp[n]
    dp[n] = fib(n - 2, dp) + fib(n - 1, dp)
    return dp[n]


"""
CLIMBING STAIRS
"""
# You are climbing a staircase. It takes n steps to reach the top.


# Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
# class Solution:
def climbStairs(self, n: int) -> int:

    if n <= 1:
        return 1
    dp = [0] * (n + 1)

    # if you are on the ground, the only way to get there is one path, you can't say zero else you won't end
    # eg n = 2
    # dp[2] = f(2-2) + f(2-1) = 0 + 1 = 2 which is incorrect, that why f(0) is counted as one
    # if you are at  the stair one, the only way to to get to the ground is one way  (n-1)

    # since it's tabulation you build from button to top

    dp[0] = 1
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[i]


"""You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor."""


class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n = len(cost)
        dp = [0] * (n + 1)

        if n <= 1:
            return 0
        # you can either stand on index 0 or 1. so from there it does'nt count
        dp[0] = 0
        dp[1] = 0
        # when you take two step or one step and you land you pay for it... the you take the minimum This is DP tabulation so
        # we move from button to top.
        for i in range(2, n + 1):
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])
        return dp[i]


"""
FROG JUMP
There is a frog on the '1st' step of an 'N' stairs long staircase. The frog wants to reach the 'Nth' stair. 'HEIGHT[i]' is the height of the '(i+1)th' stair.If Frog jumps from 'ith' to 'jth' stair, the energy lost in the jump is given by absolute value of ( HEIGHT[i-1] - HEIGHT[j-1] ). If the Frog is on 'ith' staircase, he can jump either to '(i+1)th' stair or to '(i+2)th' stair. Your task is to find the minimum total energy used by the frog to reach from '1st' stair to 'Nth' stair.

For Example
If the given ‘HEIGHT’ array is [10,20,30,10], the answer 20 as the frog can jump from 1st stair to 2nd stair (|20-10| = 10 energy lost) and then a jump from 2nd stair to last stair (|10-20| = 10 energy lost). So, the total energy lost is 20.
"""
from os import *
from sys import *
from collections import *
from math import *

from typing import *


def frogJump(n: int, heights: List[int]) -> int:
    dp = [-1] * (n)

    def solve(i):

        if i == 0:
            return 0
        if dp[i] != -1:
            return dp[i]
        # check for one and two step:
        left = solve(i - 1) + abs(heights[i] - heights[i - 1])

        right = float("inf")
        if i > 1:
            right = solve(i - 2) + abs(heights[i] - heights[i - 2])

        dp[i] = min(left, right)
        return dp[i]  # to be used in the next iteration

    return solve(n - 1)
    pass


"""Tabulation"""


def frogJump(n: int, heights: List[int]) -> int:
    dp = [float("inf")]
    dp[0] = 0

    for i in range(1, n):
        left = dp[i] + heights[i] - heights(i - 1)

        right = float("inf")
        if i > 1:  # meaning if we are at 0, can we jump to i + 2
            right = dp[i] + heights[i] - heights[i - 2]

        dp[i] = min(left, right)
    return dp[n - 1]
    pass


""" Tabulation version when given k i.e jump k + 1, k + 2, k + 3...."""
k = 5


def frogJump(n: int, heights: List[int]) -> int:

    dp = [float("inf")] * n
    # base case: meaning when we reach the top the stairs
    dp[0] = 0

    for i in range(1, n):  #
        # try all possible jumps
        for j in range(1, k + 1):
            # we want to know if we can jump from index zero to the current i
            if i - j >= 0:
                # dp of i is infinity
                dp[i] = min(dp[i], dp[i - j] + abs(heights[i] - heights[i - j]))
        return dp[n - 1]  # this is the last element


"""983. Minimum Cost For Tickets"""


class Solution:
    def mincostTickets(self, days: List[int], costs: List[int]) -> int:
        # minimum cost
        # when i get a pass for today, will it be able to cover for the subsequent days and what will be the the minimum.
        # Max_day = 30 from the first test case. we should be able to cate fro that day and beyond. The max pass is 30 so we should be able to cater for the next 30 days

        # Tabulation

        last_day = days[-1]
        travel = set(days)
        dp = [0] * (last_day + 31)  # covering for 30 + 1 index

        for d in range(last_day, -1, -1):
            if d not in travel:
                dp[d] = dp[d + 1]
            else:
                dp[d] = min(
                    costs[0] + dp[d + 1], costs[1] + dp[d + 7], costs[2] + dp[d + 30]
                )

        return dp[0]


class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        prefix = 1
        answer = [1] * n

        for i in range(n):
            answer[i] = prefix
            prefix *= nums[i]

        suffix = 1

        for i in range(n - 1, -1, -1):
            answer[i] *= suffix  # suffix product  x prefix product
            suffix *= nums[i]

        return answer


class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:

        act_set = set(nums)
        longest = 0

        for n in act_set:
            if n - 1 not in act_set:  # start sequece
                length = 1
                while n + length in act_set:
                    length += 1
                longest = max(longest, length)

        return longest


class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # question is in two folds
        # 1. best time to buy
        # 2. best time to sell

        min_val = float("inf")
        profit = 0

        for price in prices:
            if price < min_val:
                min_val = price  # best time to buy
            else:

                profit = max(profit, price - min_val)  # best time to sell

        return profit
