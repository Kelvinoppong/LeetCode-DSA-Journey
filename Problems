""":
LONGEST SUBSTRING WITHOUT REPEATING CHARACTER
- We use the sliding window technique with two pointers: left (l) and right (r).
- The right pointer moves forward one character at a time to expand the window.
- A set is used to keep track of characters currently in the window.
- If the character at the right pointer already exists in the set, it means we have a duplicate.
- To resolve this, we shrink the window from the left by removing characters from the set and moving the left pointer forward until the duplicate is removed.
- After adding the current character to the set, we update the maximum window size.
- This process continues until the right pointer has traversed the entire string.
"""


class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        max_len = 0
        l = 0
        seen = set()
        for r in range(len(s)):
            while s[r] in seen:
                seen.remove(s[l])
                l += 1
            seen.add(s[r])
            max_len = max(max_len, r - l + 1)
        return max_len


"""
FIBONACCI
The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

F(0) = 0, F(1) = 1
F(n) = F(n - 1) + F(n - 2), for n > 1.
Given n, calculate F(n).


"""


# Tabulation
class Solution:
    def fib(self, n: int) -> int:

        if n <= 1:
            return n
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 1

        for i in range(2, n + 1):
            dp[i] = dp[i - 1] + dp[i - 2]

        return dp[i]


# Using Memoization
def fib(n, dp=None):
    if dp is None:
        dp = [-1] * (n + 1)
    if n <= 1:
        return n
    if dp[n] != -1:
        return dp[n]
    dp[n] = fib(n - 2, dp) + fib(n - 1, dp)
    return dp[n]


"""
CLIMBING STAIRS
"""
# You are climbing a staircase. It takes n steps to reach the top.


# Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
# class Solution:
def climbStairs(self, n: int) -> int:

    if n <= 1:
        return 1
    dp = [0] * (n + 1)

    # if you are on the ground, the only way to get there is one path, you can't say zero else you won't end
    # eg n = 2
    # dp[2] = f(2-2) + f(2-1) = 0 + 1 = 2 which is incorrect, that why f(0) is counted as one
    # if you are at  the stair one, the only way to to get to the ground is one way  (n-1)

    # since it's tabulation you build from button to top

    dp[0] = 1
    dp[1] = 1

    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    return dp[i]
